<!DOCTYPE html>
<!--[if IE 8]>
<html class="no-js lt-ie9" lang="en"> <![endif]-->
<!--[if gt IE 8]><!-->
<html class="no-js" lang="en"> <!--<![endif]-->
<head>
    <meta charset="utf-8">

    <meta content="width=device-width, initial-scale=1.0" name="viewport">

    <title>LevelSetFlow &mdash; infragit 1a documentation</title>


    <link href="../_static/css/theme.css" rel="stylesheet" type="text/css"/>
    <link href="../_static/pygments.css" rel="stylesheet" type="text/css"/>
    <link href="../genindex.html" rel="index" title="Index"/>
    <link href="../search.html" rel="search" title="Search"/>


    <script src="../_static/js/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav">


<div class="wy-grid-for-nav">


    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
        <div class="wy-side-scroll">
            <div class="wy-side-nav-search">


                <a class="icon icon-home" href="../index.html"> infragit


                </a>


                <div class="version">
                    0.1.0
                </div>


                <div role="search">
                    <form action="../search.html" class="wy-form" id="rtd-search-form" method="get">
                        <input name="q" placeholder="Search docs" type="text"/>
                        <input name="check_keywords" type="hidden" value="yes"/>
                        <input name="area" type="hidden" value="default"/>
                    </form>
                </div>


            </div>

            <div aria-label="main navigation" class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation">


                <ul>
                    <li class="toctree-l1"><a class="reference internal" href="../IOFactory.html">IO Factory</a></li>
                    <li class="toctree-l1"><a class="reference internal" href="../Datasets/Datasets.html">Data set
                        classes</a></li>
                    <li class="toctree-l1"><a class="reference internal" href="../Properties/BaseProperty.html">Properties</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal"
                                              href="../Factories/Factories.html">Factories</a></li>
                    <li class="toctree-l1"><a class="reference internal" href="../LevelSets/LevelSets.html">Level Set
                        functions and factory</a></li>
                    <li class="toctree-l1"><a class="reference internal" href="../Utils/EigenFactory.html">Eigen Factory
                        Documentation</a></li>
                    <li class="toctree-l1"><a class="reference internal" href="../Utils/Utils.html">General
                        Utilities</a></li>
                    <li class="toctree-l1"><a class="reference internal" href="../Visualizations/Visualization.html">Visualization
                        Classes</a></li>
                </ul>


            </div>
        </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">


        <nav aria-label="top navigation" class="wy-nav-top">

            <i class="fa fa-bars" data-toggle="wy-nav-top"></i>
            <a href="../index.html">infragit</a>

        </nav>


        <div class="wy-nav-content">

            <div class="rst-content">


                <div aria-label="breadcrumbs navigation" role="navigation">

                    <ul class="wy-breadcrumbs">

                        <li><a href="../index.html">Docs</a> &raquo;</li>

                        <li><a href="index.html">Module code</a> &raquo;</li>

                        <li>LevelSetFlow</li>


                        <li class="wy-breadcrumbs-aside">

                        </li>

                    </ul>


                    <hr/>
                </div>
                <div class="document" itemscope="itemscope" itemtype="http://schema.org/Article" role="main">
                    <div itemprop="articleBody">

                        <h1>Source code for LevelSetFlow</h1>
                        <div class="highlight"><pre>
<span></span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">infragit</span>
<span class="sd">reuma\Reuma</span>
<span class="sd">07, Jan, 2018 </span>
<span class="sd">&#39;&#39;&#39;</span>

<span class="kn">import</span> <span class="nn">cv2</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">from</span> <span class="nn">matplotlib</span> <span class="k">import</span> <span
                                class="n">pyplot</span> <span class="k">as</span> <span class="n">plt</span>

<span class="kn">import</span> <span class="nn">MyTools</span> <span class="k">as</span> <span class="nn">mt</span>
<span class="kn">import</span> <span class="nn">Saliency</span> <span class="k">as</span> <span class="nn">sl</span>
<span class="kn">from</span> <span class="nn">LevelSetFunction</span> <span class="k">import</span> <span class="n">LevelSetFunction</span>
<span class="kn">from</span> <span class="nn">RasterData</span> <span class="k">import</span> <span
                                class="n">RasterData</span>
<span class="kn">from</span> <span class="nn">SaliencyFactory</span> <span class="k">import</span> <span class="n">SaliencyFactory</span>

<span class="n">EPS</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">finfo</span><span
                                class="p">(</span><span class="nb">float</span><span class="p">)</span><span
                                class="o">.</span><span class="n">eps</span>


<div class="viewcode-block" id="LevelSetFlow"><a class="viewcode-back"
                                                 href="../LevelSets/LevelSetFlow.html#LevelSetFlow.LevelSetFlow">[docs]</a><span
        class="k">class</span> <span class="nc">LevelSetFlow</span><span class="p">:</span>
    <span class="c1"># General initializations</span>
    <span class="n">__processing_props</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;gradientType&#39;</span><span
            class="p">:</span> <span class="s1">&#39;L1&#39;</span><span class="p">,</span> <span class="s1">&#39;sigma&#39;</span><span
            class="p">:</span> <span class="mf">2.5</span><span class="p">,</span> <span
            class="s1">&#39;ksize&#39;</span><span class="p">:</span> <span class="mi">5</span><span class="p">,</span> <span
            class="s1">&#39;regularization&#39;</span><span class="p">:</span> <span class="mi">0</span><span class="p">}</span>
    <span class="n">__flow_types</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;geodesic&#39;</span><span
            class="p">:</span> <span class="mf">1.</span><span class="p">}</span>
    <span class="n">__regularization_epsilon</span> <span class="o">=</span> <span class="n">EPS</span>
    <span class="n">__iterations</span> <span class="o">=</span> <span class="mi">150</span>
    <span class="n">__step</span> <span class="o">=</span> <span class="mf">1.</span>  <span
            class="c1"># step size</span>

    <span class="c1"># Weighting initializations</span>
    <span class="n">__gvf_w</span> <span class="o">=</span> <span class="mf">1.</span>
    <span class="n">__vo_w</span> <span class="o">=</span> <span class="mf">0.</span>
    <span class="n">__region_w</span> <span class="o">=</span> <span class="mf">1.</span>

    <span class="c1"># Level set initializations</span>
    <span class="n">__Phi</span> <span class="o">=</span> <span class="p">[]</span>  <span
            class="c1"># LevelSetFunction</span>
    <span class="n">__img</span> <span class="o">=</span> <span class="p">[]</span>  <span class="c1"># the analyzed image (of the data)</span>
    <span class="n">__img_rgb</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="c1"># Constraints initializations</span>
    <span class="n">__imgGradient</span> <span class="o">=</span> <span class="kc">None</span>  <span
            class="c1">#</span>

    <span class="n">__g</span> <span class="o">=</span> <span class="kc">None</span>  <span
            class="c1"># internal force</span>
    <span class="n">__g_x</span> <span class="o">=</span> <span class="n">__g_y</span> <span class="o">=</span> <span
            class="kc">None</span>  <span class="c1"># g derivatives</span>

    <span class="n">__region</span> <span class="o">=</span> <span class="kc">None</span>  <span class="c1"># region constraint</span>

    <span class="n">__f</span> <span class="o">=</span> <span class="kc">None</span>  <span class="c1"># external force (for GVF)</span>
    <span class="n">__f_x</span> <span class="o">=</span> <span class="n">__f_y</span> <span class="o">=</span> <span
            class="kc">None</span>
    <span class="n">__psi</span> <span class="o">=</span> <span class="p">[]</span>  <span class="c1"># internal force, for open contours;  LevelSetFunction</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span
            class="p">,</span> <span class="n">img</span><span class="p">,</span> <span class="o">**</span><span
            class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Initialize factory.</span>

<span class="sd">        :param img: the image upon which the level set is started.</span>
<span class="sd">        :param imb_rgb: an rgb image if exists</span>
<span class="sd">        :param step: time step for advancing the level set function.</span>
<span class="sd">        :param flow_types: the flow types according to which the level set moves with their weights. According to</span>
<span class="sd">        :py:meth:`~LevelSetFactory.LevelSetFactory.flow`</span>
<span class="sd">        :param weights: all weights to move the level set. According to</span>
<span class="sd">        :py:meth:`~LevelSetFactory.LevelSetFactory.set_weights`</span>

<span class="sd">        :type img: np.array</span>
<span class="sd">        :type img_rgb: np.array</span>
<span class="sd">        :type step: float</span>
<span class="sd">        :type flow_types: dict</span>
<span class="sd">        :type weights: dict</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">__step</span> <span class="o">=</span> <span
            class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span
            class="s1">&#39;step&#39;</span><span class="p">,</span> <span class="mf">0.05</span><span
            class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__iterations</span> <span class="o">=</span> <span
            class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span
            class="s1">&#39;iterations&#39;</span><span class="p">,</span> <span class="mi">150</span><span
            class="p">)</span>
        <span class="k">if</span> <span class="s1">&#39;img_rgb&#39;</span> <span class="ow">in</span> <span class="nb">list</span><span
            class="p">(</span><span class="n">kwargs</span><span class="o">.</span><span class="n">keys</span><span
            class="p">()):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__img_rgb</span> <span
            class="o">=</span> <span class="n">kwargs</span><span class="p">[</span><span
            class="s1">&#39;img_rgb&#39;</span><span class="p">]</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span
            class="n">img</span><span class="p">,</span> <span class="n">RasterData</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__img</span><span
            class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">img</span><span
            class="o">.</span><span class="n">data</span><span class="p">)</span>
            <span class="c1"># self.data = img</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span
            class="n">img</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">__img</span> <span
            class="o">=</span> <span class="n">img</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">__img</span><span class="o">.</span><span
            class="n">append</span><span class="p">(</span><span class="n">img</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">__Phi</span> <span class="o">=</span> <span
            class="p">[</span><span class="n">LevelSetFunction</span><span class="p">(</span><span
            class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span
            class="bp">self</span><span class="o">.</span><span class="n">img</span><span class="p">()</span><span
            class="o">.</span><span class="n">shape</span><span class="p">))]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__psi</span> <span class="o">=</span> <span
            class="p">[</span><span class="n">LevelSetFunction</span><span class="p">(</span><span
            class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span
            class="bp">self</span><span class="o">.</span><span class="n">img</span><span class="p">()</span><span
            class="o">.</span><span class="n">shape</span><span class="p">))]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__region</span> <span
            class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span
            class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">img</span><span
            class="p">()</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__f</span> <span class="o">=</span> <span
            class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span
            class="bp">self</span><span class="o">.</span><span class="n">img</span><span class="p">()</span><span
            class="o">.</span><span class="n">shape</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__g</span> <span class="o">=</span> <span
            class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span
            class="bp">self</span><span class="o">.</span><span class="n">img</span><span class="p">()</span><span
            class="o">.</span><span class="n">shape</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">scale_x</span> <span
            class="o">=</span> <span class="mi">1</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">scale_y</span> <span
            class="o">=</span> <span class="mi">1</span>

        <span class="k">if</span> <span class="s1">&#39;weights&#39;</span> <span class="ow">in</span> <span class="nb">list</span><span
            class="p">(</span><span class="n">kwargs</span><span class="o">.</span><span class="n">keys</span><span
            class="p">()):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">set_weights</span><span
            class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">[</span><span
            class="s1">&#39;weights&#39;</span><span class="p">])</span>

        <span class="k">if</span> <span class="s1">&#39;flow_types&#39;</span> <span class="ow">in</span> <span
            class="nb">list</span><span class="p">(</span><span class="n">kwargs</span><span class="o">.</span><span
            class="n">keys</span><span class="p">()):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">set_flow_types</span><span
            class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">[</span><span
            class="s1">&#39;flow_types&#39;</span><span class="p">])</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">num_ls</span><span class="p">(</span><span class="bp">self</span><span
            class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Number of level sets in the flow</span>

<span class="sd">        :return: int</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span
            class="bp">self</span><span class="o">.</span><span class="n">__Phi</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">processing_props</span><span class="p">(</span><span
            class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__processing_props</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">flow_types</span><span class="p">(</span><span
            class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Types of flow used to progress the curves</span>

<span class="sd">        Default: {&quot;geodesic&quot;}</span>

<span class="sd">        :rtype: dict</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span
            class="n">__flow_types</span>

<div class="viewcode-block" id="LevelSetFlow.set_flow_types"><a class="viewcode-back"
                                                                href="../LevelSets/LevelSetFlow.html#LevelSetFlow.LevelSetFlow.set_flow_types">[docs]</a>    <span
        class="k">def</span> <span class="nf">set_flow_types</span><span class="p">(</span><span
        class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span
        class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Set the flow types and their weights according to which the level set will move</span>

<span class="sd">        Options are as in :py:meth:`~LevelSetFactory.LevelSetFactory.flow`</span>

<span class="sd">        For example:</span>

<span class="sd">        .. code-block:: python</span>

<span class="sd">            set_flow_types(geodesic=1., curvature=.2, equi_affine: 0.5})</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">flow_types</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;geodesic&#39;</span><span
            class="p">:</span> <span class="mf">1.</span><span class="p">,</span>
                      <span class="s1">&#39;curvature&#39;</span><span class="p">:</span> <span
            class="mf">0.</span><span class="p">,</span>
                      <span class="s1">&#39;equi_affine&#39;</span><span class="p">:</span> <span
            class="mf">0.</span><span class="p">,</span>
                      <span class="s1">&#39;band&#39;</span><span class="p">:</span> <span class="mf">0.</span><span
            class="p">}</span>
        <span class="n">flow_types</span><span class="o">.</span><span class="n">update</span><span
            class="p">(</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__flow_types</span> <span class="o">=</span> <span
            class="n">flow_types</span></div>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">regularization_epsilon</span><span class="p">(</span><span class="bp">self</span><span
            class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>

<span class="sd">        :rtype: float</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__regularization_epsilon</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">iterations</span><span class="p">(</span><span
            class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Number of iterations for the level set</span>

<span class="sd">        Default: 150</span>

<span class="sd">        :rtype: int</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span
            class="n">__iterations</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">step</span><span class="p">(</span><span class="bp">self</span><span
            class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Step size for the level set progression</span>

<span class="sd">        Default: 0.05</span>

<span class="sd">        :rtype: float</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__step</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">gvf_w</span><span class="p">(</span><span class="bp">self</span><span
            class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Gradient vector flow weight</span>

<span class="sd">        Default: 1.</span>

<span class="sd">        :rtype: float</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__gvf_w</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">vo_w</span><span class="p">(</span><span class="bp">self</span><span
            class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Open velocity flow weight</span>

<span class="sd">        Default: 1.</span>

<span class="sd">        :rtype: float</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__vo_w</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">region_w</span><span class="p">(</span><span class="bp">self</span><span
            class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Region weight</span>

<span class="sd">        Default: 1.</span>

<span class="sd">        :rtype: float</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span
            class="n">__region_w</span>

<div class="viewcode-block" id="LevelSetFlow.set_weights"><a class="viewcode-back"
                                                             href="../LevelSets/LevelSetFlow.html#LevelSetFlow.LevelSetFlow.set_weights">[docs]</a>    <span
        class="k">def</span> <span class="nf">set_weights</span><span class="p">(</span><span
        class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span
        class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Set weights for constraints.</span>

<span class="sd">        :param gvf_w: gradient vector flow weight</span>
<span class="sd">        :param vo_w: open contour weight (Not working at the moment)</span>
<span class="sd">        :param region_w: region constraint weight</span>

<span class="sd">        :type gvf_w: float</span>
<span class="sd">        :type vo_w: float</span>
<span class="sd">        :type region_w: float</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">inputs</span> <span class="o">=</span> <span class="p">{</span><span
            class="s1">&#39;gvf_w&#39;</span><span class="p">:</span> <span class="mf">1.</span><span class="p">,</span>
                  <span class="s1">&#39;vo_w&#39;</span><span class="p">:</span> <span class="mf">0.</span><span
            class="p">,</span>
                  <span class="s1">&#39;region_w&#39;</span><span class="p">:</span> <span class="mf">1.</span><span
            class="p">,</span>
                  <span class="p">}</span>

        <span class="n">inputs</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span
            class="n">kwargs</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__region_w</span> <span
            class="o">=</span> <span class="n">inputs</span><span class="p">[</span><span
            class="s1">&#39;region_w&#39;</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__gvf_w</span> <span
            class="o">=</span> <span class="n">inputs</span><span class="p">[</span><span
            class="s1">&#39;gvf_w&#39;</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__vo_w</span> <span class="o">=</span> <span
            class="n">inputs</span><span class="p">[</span><span class="s1">&#39;vo_w&#39;</span><span
            class="p">]</span></div>

<div class="viewcode-block" id="LevelSetFlow.img"><a class="viewcode-back"
                                                     href="../LevelSets/LevelSetFlow.html#LevelSetFlow.LevelSetFlow.img">[docs]</a>    <span
        class="k">def</span> <span class="nf">img</span><span class="p">(</span><span class="bp">self</span><span
        class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The analyzed image (of the data). Multiple can exist.</span>

<span class="sd">        :param index: the index of the analyzed images.</span>

<span class="sd">        :type index: int</span>

<span class="sd">        :rtype: np.ndarray</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span
            class="n">__img</span><span class="p">[</span><span class="n">index</span><span class="p">]</span></div>

<div class="viewcode-block" id="LevelSetFlow.update_img"><a class="viewcode-back"
                                                            href="../LevelSets/LevelSetFlow.html#LevelSetFlow.LevelSetFlow.update_img">[docs]</a>    <span
        class="k">def</span> <span class="nf">update_img</span><span class="p">(</span><span class="bp">self</span><span
        class="p">,</span> <span class="n">new_img</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Adds another image (of the data).</span>

<span class="sd">        :param new_img: the new image to add</span>

<span class="sd">        :type new_img: np.ndarray</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__img</span><span class="o">.</span><span
            class="n">append</span><span class="p">(</span><span class="n">new_img</span><span class="p">)</span></div>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">img_rgb</span><span class="p">(</span><span class="bp">self</span><span
            class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The analyzed img rgb representation (if exists, otherwise: 0.)</span>

<span class="sd">        Default: 0</span>

<span class="sd">        :rtype: np.array or 0</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span
            class="n">__img_rgb</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">region</span><span class="p">(</span><span class="bp">self</span><span
            class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Region constraint</span>

<span class="sd">        :rtype: np.array</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span
            class="n">__region</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">imgGradient</span><span class="p">(</span><span
            class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Gradient of the analyzed image</span>

<span class="sd">        :rtype: np.array</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span
            class="n">__imgGradient</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">g</span><span class="p">(</span><span class="bp">self</span><span
            class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Internal force (usually edge function)</span>

<span class="sd">        :rtype: np.array</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__g</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">g_x</span><span class="p">(</span><span class="bp">self</span><span
            class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        First order derivative of the internal force</span>

<span class="sd">        :rtype: np.array</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span
            class="n">__g_x</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span
            class="n">scale_x</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">g_y</span><span class="p">(</span><span class="bp">self</span><span
            class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        First order derivative of the internal force</span>

<span class="sd">        :rtype: np.array</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span
            class="n">__g_y</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span
            class="n">scale_y</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">f</span><span class="p">(</span><span class="bp">self</span><span
            class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        External force (for gradient vector flow)</span>

<span class="sd">        :rtype: np.array</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__f</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">f_x</span><span class="p">(</span><span class="bp">self</span><span
            class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        First order derivative of the external force</span>

<span class="sd">        :rtype: np.array</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__f_x</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">f_y</span><span class="p">(</span><span class="bp">self</span><span
            class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        First order derivative of the external force</span>

<span class="sd">        :rtype: np.array</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__f_y</span>

<div class="viewcode-block" id="LevelSetFlow.phi"><a class="viewcode-back"
                                                     href="../LevelSets/LevelSetFlow.html#LevelSetFlow.LevelSetFlow.phi">[docs]</a>    <span
        class="k">def</span> <span class="nf">phi</span><span class="p">(</span><span class="bp">self</span><span
        class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the level set function phi according to the index</span>

<span class="sd">        :param index: the number of the level set</span>

<span class="sd">        :type index: int</span>

<span class="sd">        :return: LevelSetFunction self.__Phi</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span
            class="n">__Phi</span><span class="p">[</span><span class="n">index</span><span class="p">]</span></div>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">psi</span><span class="p">(</span><span class="bp">self</span><span
            class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="mi">0</span><span
            class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the level set function phi according to the index</span>
<span class="sd">        :return: LevelSetFunction self.__psi</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span
            class="n">__psi</span><span class="p">[</span><span class="n">index</span><span class="p">]</span>

<div class="viewcode-block" id="LevelSetFlow.init_phi"><a class="viewcode-back"
                                                          href="../LevelSets/LevelSetFlow.html#LevelSetFlow.LevelSetFlow.init_phi">[docs]</a>    <span
        class="k">def</span> <span class="nf">init_phi</span><span class="p">(</span><span class="bp">self</span><span
        class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Builds an initial smooth function (Lipschitz continuous) that represents the interface as the set where</span>
<span class="sd">        phi(x,y,t) = 0 is the curve.</span>

<span class="sd">        The function has the following characteristics:</span>

<span class="sd">        .. math::</span>
<span class="sd">            \begin{cases}</span>
<span class="sd">             \phi(x,y,t) &gt; 0 &amp; \forall (x,y) \in \Omega \\</span>
<span class="sd">             \phi(x,y,t) &lt; 0 &amp; \forall (x,y) \not\in \Omega \\</span>
<span class="sd">             \phi(x,y,t) = 0 &amp; \forall (x,y) \textrm{ on curve} \\</span>
<span class="sd">             \end{cases}</span>

<span class="sd">        with :math:`\left| \nabla \phi \right| = 1`</span>

<span class="sd">        **Characteristics of the function**</span>

<span class="sd">        :param processing_props: properties for gradient and differentiation:</span>
<span class="sd">            - &#39;gradientType&#39; - distance computation method</span>
<span class="sd">            - &#39;sigma&#39; - for smoothing</span>
<span class="sd">            - &#39;ksize&#39; - for smoothing</span>

<span class="sd">        :param radius: if the curve is a circle, the radius should be specified.</span>
<span class="sd">        :param center_pt: if the curve is a circle, the center point should be specified.</span>
<span class="sd">        :param reularization_note: regularization note for heaviside function</span>
<span class="sd">        :param function_type: &#39;circle&#39; (default); &#39;vertical&#39; or &#39;horizontal&#39; (for open contours)</span>

<span class="sd">        :type processing_props: dict</span>
<span class="sd">        :type radius: int</span>
<span class="sd">        :type center_pt: tuple</span>
<span class="sd">        :type function_type: str</span>
<span class="sd">        :type start: tuple</span>
<span class="sd">        :type regularization_note: int 0,1,2</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">processing_props</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;gradientType&#39;</span><span
            class="p">:</span> <span class="s1">&#39;L1&#39;</span><span class="p">,</span> <span class="s1">&#39;sigma&#39;</span><span
            class="p">:</span> <span class="mf">2.5</span><span class="p">,</span> <span
            class="s1">&#39;ksize&#39;</span><span class="p">:</span> <span class="mi">5</span><span class="p">}</span>
        <span class="k">if</span> <span class="s1">&#39;processing_props&#39;</span> <span class="ow">in</span> <span
            class="n">kwargs</span><span class="p">:</span>
            <span class="n">processing_props</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span
            class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;processing_props&#39;</span><span
            class="p">])</span>
        <span class="n">img_height</span><span class="p">,</span> <span class="n">img_width</span> <span
            class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">img</span><span
            class="p">()</span><span class="o">.</span><span class="n">shape</span><span class="p">[:</span><span
            class="mi">2</span><span class="p">]</span>
        <span class="n">radius</span> <span class="o">=</span> <span class="n">kwargs</span><span
            class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;radius&#39;</span><span
            class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">int</span><span
            class="p">(</span><span class="n">img_width</span> <span class="o">/</span> <span class="mi">4</span><span
            class="p">))</span>
        <span class="n">center_pt</span> <span class="o">=</span> <span class="n">kwargs</span><span
            class="o">.</span><span class="n">get</span><span class="p">(</span><span
            class="s1">&#39;center_pt&#39;</span><span class="p">,</span> <span class="p">[</span><span
            class="n">np</span><span class="o">.</span><span class="n">int</span><span class="p">(</span><span
            class="n">img_height</span> <span class="o">/</span> <span class="mi">2</span><span
            class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">int</span><span
            class="p">(</span><span class="n">img_width</span> <span class="o">/</span> <span class="mi">2</span><span
            class="p">)])</span>
        <span class="n">func_type</span> <span class="o">=</span> <span class="n">kwargs</span><span
            class="o">.</span><span class="n">get</span><span class="p">(</span><span
            class="s1">&#39;function_type&#39;</span><span class="p">,</span> <span
            class="s1">&#39;circle&#39;</span><span class="p">)</span>

        <span class="n">regularization</span> <span class="o">=</span> <span class="n">kwargs</span><span
            class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;regularization_note&#39;</span><span
            class="p">,</span> <span class="mi">0</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">func_type</span> <span class="o">==</span> <span class="s1">&#39;circle&#39;</span><span
            class="p">:</span>
            <span class="n">phi</span> <span class="o">=</span> <span class="n">LevelSetFunction</span><span
            class="o">.</span><span class="n">dist_from_circle</span><span class="p">(</span><span
            class="n">center_pt</span><span class="p">,</span> <span class="n">radius</span><span
            class="p">,</span> <span class="p">(</span><span class="n">img_height</span><span class="p">,</span> <span
            class="n">img_width</span><span class="p">),</span>
                                                    <span class="n">ksize</span><span class="o">=</span><span class="n">processing_props</span><span
            class="p">[</span><span class="s1">&#39;ksize&#39;</span><span class="p">])</span>

        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span
            class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__Phi</span><span
            class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">value</span> <span
            class="o">==</span> <span class="mi">0</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__Phi</span> <span
            class="o">=</span> <span class="p">[]</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">__Phi</span><span class="o">.</span><span
            class="n">append</span><span class="p">(</span>
            <span class="n">LevelSetFunction</span><span class="p">(</span><span class="n">phi</span><span
            class="p">,</span> <span class="n">regularization_note</span><span class="o">=</span><span class="n">regularization</span><span
            class="p">,</span>
                             <span class="n">epsilon</span><span class="o">=</span><span class="mf">1e-8</span><span
            class="p">,</span>
                             <span class="o">**</span><span class="n">processing_props</span><span
            class="p">))</span></div>

<div class="viewcode-block" id="LevelSetFlow.init_img"><a class="viewcode-back"
                                                          href="../LevelSets/LevelSetFlow.html#LevelSetFlow.LevelSetFlow.init_img">[docs]</a>    <span
        class="k">def</span> <span class="nf">init_img</span><span class="p">(</span><span class="bp">self</span><span
        class="p">,</span> <span class="n">img</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span
        class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Set more images for the level set flow, according to which the flow will move (each of the Phi&#39;s)</span>

<span class="sd">        .. warning::</span>
<span class="sd">            When initializing a second+ image, one should make sure that</span>

<span class="sd">        :param img: the next image to set</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__img</span><span class="o">.</span><span
            class="n">append</span><span class="p">(</span><span class="n">img</span><span class="p">)</span></div>

<div class="viewcode-block" id="LevelSetFlow.init_psi"><a class="viewcode-back"
                                                          href="../LevelSets/LevelSetFlow.html#LevelSetFlow.LevelSetFlow.init_psi">[docs]</a>    <span
        class="k">def</span> <span class="nf">init_psi</span><span class="p">(</span><span class="bp">self</span><span
        class="p">,</span> <span class="n">psi</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span
        class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">         Initializes the psi function (open edges)</span>

<span class="sd">        :param psi: the function</span>
<span class="sd">        :param processing_props: gradient process dictionary</span>

<span class="sd">        :type psi: nd-array mxn</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span
            class="n">arange</span><span class="p">(</span><span class="n">psi</span><span class="o">.</span><span
            class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
        <span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span
            class="n">arange</span><span class="p">(</span><span class="n">psi</span><span class="o">.</span><span
            class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="n">xx</span><span class="p">,</span> <span class="n">yy</span> <span class="o">=</span> <span
            class="n">np</span><span class="o">.</span><span class="n">meshgrid</span><span class="p">(</span><span
            class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
        <span class="n">dists</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span
            class="n">sqrt</span><span class="p">(</span><span class="n">xx</span> <span class="o">**</span> <span
            class="mi">2</span> <span class="o">+</span> <span class="n">yy</span> <span class="o">**</span> <span
            class="mi">2</span><span class="p">)</span>
        <span class="n">dists</span> <span class="o">/=</span> <span class="n">np</span><span class="o">.</span><span
            class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span
            class="n">dists</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span
            class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__psi</span><span
            class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">value</span> <span
            class="o">==</span> <span class="mi">0</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__psi</span> <span
            class="o">=</span> <span class="p">[]</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">__psi</span><span class="o">.</span><span
            class="n">append</span><span class="p">(</span><span class="n">LevelSetFunction</span><span
            class="p">(</span><span class="n">psi</span> <span class="o">*</span> <span class="n">dists</span><span
            class="p">,</span> <span class="bp">self</span><span class="o">.</span><span
            class="n">processing_props</span><span class="p">))</span></div>

<div class="viewcode-block" id="LevelSetFlow.init_g"><a class="viewcode-back"
                                                        href="../LevelSets/LevelSetFlow.html#LevelSetFlow.LevelSetFlow.init_g">[docs]</a>    <span
        class="k">def</span> <span class="nf">init_g</span><span class="p">(</span><span class="bp">self</span><span
        class="p">,</span> <span class="n">g</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span
        class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Initializes the g function (edge function)</span>
<span class="sd">        :param g: the function</span>
<span class="sd">        :param kwargs: gradient process dictionary</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__g</span> <span class="o">=</span> <span
            class="n">g</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__g_x</span><span class="p">,</span> <span
            class="bp">self</span><span class="o">.</span><span class="n">__g_y</span> <span class="o">=</span> <span
            class="n">mt</span><span class="o">.</span><span class="n">computeImageDerivatives</span><span
            class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span
            class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>

<div class="viewcode-block" id="LevelSetFlow.init_f"><a class="viewcode-back"
                                                        href="../LevelSets/LevelSetFlow.html#LevelSetFlow.LevelSetFlow.init_f">[docs]</a>    <span
        class="k">def</span> <span class="nf">init_f</span><span class="p">(</span><span class="bp">self</span><span
        class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span
        class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Initializes the g function (edge function)</span>
<span class="sd">        :param g: the function</span>
<span class="sd">        :param kwargs: gradient process dictionary</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__f</span> <span class="o">=</span> <span
            class="n">f</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__f_x</span><span class="p">,</span> <span
            class="bp">self</span><span class="o">.</span><span class="n">__f_y</span> <span class="o">=</span> <span
            class="n">mt</span><span class="o">.</span><span class="n">computeImageDerivatives</span><span
            class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span
            class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>

<div class="viewcode-block" id="LevelSetFlow.init_region"><a class="viewcode-back"
                                                             href="../LevelSets/LevelSetFlow.html#LevelSetFlow.LevelSetFlow.init_region">[docs]</a>    <span
        class="k">def</span> <span class="nf">init_region</span><span class="p">(</span><span
        class="bp">self</span><span class="p">,</span> <span class="n">region_method</span><span
        class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Initializes region function</span>

<span class="sd">        :param region_method: type of the region wanted: &#39;classification&#39;, &#39;saliency&#39;.</span>
<span class="sd">        :param img_index: the self.img according to which the region will be computed</span>

<span class="sd">        :type img_index: [int, PointSet]</span>

<span class="sd">        *Inputs according to method:*</span>

<span class="sd">        - saliency: inputs according to :py:meth:`~Saliency.distance_based`</span>

<span class="sd">        - classification:</span>

<span class="sd">        - range_saliency:</span>

<span class="sd">        :param winSizes: array or list with different window sizes for classification</span>
<span class="sd">        :param class: the classes which are looked for.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">sigma</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span
            class="n">get</span><span class="p">(</span><span class="s1">&#39;sigma&#39;</span><span class="p">,</span> <span
            class="mf">2.5</span><span class="p">)</span>
        <span class="n">index</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span
            class="n">get</span><span class="p">(</span><span class="s1">&#39;img_index&#39;</span><span
            class="p">,</span> <span class="mi">0</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">region_method</span> <span class="o">==</span> <span class="s1">&#39;saliency&#39;</span><span
            class="p">:</span>
            <span class="n">inputs</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;feature&#39;</span><span
            class="p">:</span> <span class="s1">&#39;normals&#39;</span><span class="p">,</span>
                      <span class="s1">&#39;method&#39;</span><span class="p">:</span> <span class="s1">&#39;frequency&#39;</span><span
            class="p">,</span>
                      <span class="s1">&#39;dist_type&#39;</span><span class="p">:</span> <span class="s1">&#39;Euclidean&#39;</span><span
            class="p">,</span>
                      <span class="s1">&#39;filter_sigma&#39;</span><span class="p">:</span> <span
            class="p">[</span><span class="n">sigma</span><span class="p">,</span> <span class="mf">1.6</span> <span
            class="o">*</span> <span class="n">sigma</span><span class="p">,</span> <span class="mf">1.6</span> <span
            class="o">*</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">sigma</span><span
            class="p">,</span> <span class="mf">1.6</span> <span class="o">*</span> <span class="mi">3</span> <span
            class="o">*</span> <span class="n">sigma</span><span class="p">],</span>
                      <span class="s1">&#39;filter_size&#39;</span><span class="p">:</span> <span
            class="mi">0</span><span class="p">,</span>
                      <span class="s1">&#39;scales_number&#39;</span><span class="p">:</span> <span
            class="mi">3</span><span class="p">,</span>
                      <span class="s1">&#39;verbose&#39;</span><span class="p">:</span> <span
            class="kc">True</span><span class="p">}</span>
            <span class="n">inputs</span><span class="o">.</span><span class="n">update</span><span
            class="p">(</span><span class="n">kwargs</span><span class="p">)</span>

            <span class="n">region</span> <span class="o">=</span> <span class="n">sl</span><span
            class="o">.</span><span class="n">distance_based</span><span class="p">(</span><span
            class="bp">self</span><span class="o">.</span><span class="n">img</span><span class="p">(</span><span
            class="n">index</span><span class="p">),</span> <span class="o">**</span><span class="n">inputs</span><span
            class="p">)</span>
        <span class="k">elif</span> <span class="n">region_method</span> <span class="o">==</span> <span class="s1">&#39;range_saliency&#39;</span><span
            class="p">:</span>

            <span class="n">inputs</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;range&#39;</span><span
            class="p">:</span> <span class="mf">2.</span><span class="p">}</span>
            <span class="n">inputs</span><span class="o">.</span><span class="n">update</span><span
            class="p">(</span><span class="n">kwargs</span><span class="p">)</span>
            <span class="n">region</span> <span class="o">=</span> <span class="n">SaliencyFactory</span><span
            class="o">.</span><span class="n">range_saliency</span><span class="p">(</span><span
            class="n">index</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>
            <span class="kn">from</span> <span class="nn">PanoramaFactory</span> <span class="k">import</span> <span
            class="n">PanoramaFactory</span>
            <span class="n">region</span> <span class="o">=</span> <span class="n">PanoramaFactory</span><span
            class="o">.</span><span class="n">CreatePanorama_byProperty</span><span class="p">(</span><span class="n">region</span><span
            class="p">,</span> <span class="mf">0.03</span><span class="p">,</span> <span class="mf">0.016</span><span
            class="p">,</span> <span class="n">voidData</span><span class="o">=</span><span class="mi">0</span><span
            class="p">)</span><span class="o">.</span><span class="n">PanoramaImage</span>

        <span class="k">elif</span> <span class="n">region_method</span> <span class="o">==</span> <span class="s1">&#39;PCA_Sacliency&#39;</span><span
            class="p">:</span>

            <span class="n">saliency_property</span> <span class="o">=</span> <span
            class="n">SaliencyFactory</span><span class="o">.</span><span
            class="n">pointwise_tensor_saliency</span><span class="p">()</span>

        <span class="k">elif</span> <span class="n">region_method</span> <span class="o">==</span> <span class="s1">&#39;classification&#39;</span><span
            class="p">:</span>
            <span class="n">inputs</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;winSizes&#39;</span><span
            class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span
            class="p">(</span><span class="mf">0.1</span><span class="p">,</span> <span class="mi">10</span><span
            class="p">,</span> <span class="mi">5</span><span class="p">),</span>
                      <span class="s1">&#39;class&#39;</span><span class="p">,</span> <span class="mi">1</span><span
            class="p">}</span>
            <span class="n">inputs</span><span class="o">.</span><span class="n">update</span><span
            class="p">(</span><span class="n">kwargs</span><span class="p">)</span>

            <span class="kn">from</span> <span class="nn">ClassificationFactory</span> <span
            class="k">import</span> <span class="n">ClassificationFactory</span> <span class="k">as</span> <span
            class="n">Cf</span>
            <span class="n">classified</span><span class="p">,</span> <span class="n">percentMap</span> <span class="o">=</span> <span
            class="n">Cf</span><span class="o">.</span><span class="n">SurfaceClassification</span><span
            class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">img</span><span
            class="p">(</span><span class="n">index</span><span class="p">),</span> <span class="n">inputs</span><span
            class="p">[</span><span class="s1">&#39;winSizes&#39;</span><span class="p">])</span>
            <span class="n">region</span> <span class="o">=</span> <span class="n">classified</span><span
            class="o">.</span><span class="n">classification</span><span class="p">(</span><span class="n">inputs</span><span
            class="p">[</span><span class="s1">&#39;class&#39;</span><span class="p">])</span>

        <span class="c1"># region = np.log(255 - cv2.GaussianBlur(region,</span>
        <span class="c1">#                                        ksize=(self.processing_props[&#39;ksize&#39;], self.processing_props[&#39;ksize&#39;]),</span>
        <span class="c1">#                                        sigmaX=self.processing_props[&#39;sigma&#39;]))</span>

        <span class="n">region</span> <span class="o">=</span> <span class="n">cv2</span><span class="o">.</span><span
            class="n">normalize</span><span class="p">(</span><span class="n">region</span><span class="o">.</span><span
            class="n">astype</span><span class="p">(</span><span class="s1">&#39;float&#39;</span><span
            class="p">),</span> <span class="kc">None</span><span class="p">,</span> <span class="o">-</span><span
            class="mf">1.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">,</span> <span
            class="n">cv2</span><span class="o">.</span><span class="n">NORM_MINMAX</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__region</span> <span
            class="o">=</span> <span class="n">region</span></div>

<div class="viewcode-block" id="LevelSetFlow.update_region"><a class="viewcode-back"
                                                               href="../LevelSets/LevelSetFlow.html#LevelSetFlow.LevelSetFlow.update_region">[docs]</a>    <span
        class="k">def</span> <span class="nf">update_region</span><span class="p">(</span><span
        class="bp">self</span><span class="p">,</span> <span class="n">new_region</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Updates the region according to a given new_region</span>

<span class="sd">        :param new_region: the new region according to which the level set should progress</span>

<span class="sd">        :type new_region: np.array</span>


<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__region</span> <span
            class="o">=</span> <span class="n">new_region</span></div>

<div class="viewcode-block" id="LevelSetFlow.flow"><a class="viewcode-back"
                                                      href="../LevelSets/LevelSetFlow.html#LevelSetFlow.LevelSetFlow.flow">[docs]</a>    <span
        class="k">def</span> <span class="nf">flow</span><span class="p">(</span><span class="bp">self</span><span
        class="p">,</span> <span class="n">flow_type</span><span class="p">,</span> <span class="n">function</span><span
        class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span
        class="n">kwargs</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the flow of the level set according to the type wanted</span>

<span class="sd">        :param flow_type: can be one of the following:</span>
<span class="sd">            - &#39;constant&#39;:</span>

<span class="sd">               .. math::</span>

<span class="sd">                   C_t = N \Rightarrow \phi_t = |\nabla \varphi|</span>

<span class="sd">            - &#39;curvature&#39;:</span>

<span class="sd">               .. math::</span>

<span class="sd">                    C_t = kN \Rightarrow phi_t = div\left(\frac{\nabla \varphi}{|\nabla \varphi|}\right)|\nabla \varphi|</span>

<span class="sd">            - &#39;equi_affine&#39;:</span>

<span class="sd">                .. math::</span>

<span class="sd">                    C_t = k^{1/3} N \Rightarrow</span>
<span class="sd">                    \phi_t = div\left(\frac{\nabla \varphi}{|\nabla \varphi|}\right)^{1/3}*|\nabla \varphi|</span>

<span class="sd">            - &#39;geodesic&#39;: geodesic active contours, according to :cite:`Caselles.etal1997`</span>

<span class="sd">                .. math::</span>

<span class="sd">                    C_t = (g(I)k -\nabla(g(I))N)N \Rightarrow</span>
<span class="sd">                    \phi_t = [g(I)\cdot div\left(\frac{\nabla \varphi}{|\nabla \varphi|}\right)^{1/3}*|\nabla \varphi|</span>

<span class="sd">            - &#39;band&#39;: band velocity, according to :cite:`Li.etal2006`</span>

<span class="sd">        :param function: the level set according to which the flow goes (usually phi)</span>
<span class="sd">        :param open_flag: boolean for open flag</span>


<span class="sd">        **Optionals**</span>

<span class="sd">        :param gradientType: &#39;L1&#39; L1 norm of grad(I); &#39;L2&#39; L2-norm of grad(I); &#39;LoG&#39; Laplacian of gaussian</span>
<span class="sd">        :param sigma: sigma for LoG gradient</span>
<span class="sd">        :param ksize: kernel size, for blurring and derivatives</span>
<span class="sd">        :param regularization: regularization note for heaviside and dirac</span>

<span class="sd">        **Band velocity optionals**</span>

<span class="sd">        :param band_width: the width of the contour. default: 5</span>
<span class="sd">        :param threshold: for when the velocity equals zero. default: 0.5</span>
<span class="sd">        :param stepsize: default 0.05</span>

<span class="sd">        :type flow_type: str</span>
<span class="sd">        :type function: LevelSetFunction</span>
<span class="sd">        :type open_flag: bool</span>
<span class="sd">        :type gradientType: dict</span>
<span class="sd">        :type sigma: float</span>
<span class="sd">        :type regularization: int 0,1,2</span>
<span class="sd">        :type band_width: int</span>
<span class="sd">        :type threshold: float</span>
<span class="sd">        :type stepsize: float</span>

<span class="sd">        :return: phi_t</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">flow</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="n">open_flag</span> <span class="o">=</span> <span class="n">args</span><span
            class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">processing_props</span> <span class="o">=</span> <span class="n">args</span><span
            class="p">[</span><span class="mi">1</span><span class="p">]</span>

        <span class="k">if</span> <span class="n">flow_type</span> <span class="o">==</span> <span class="s1">&#39;constant&#39;</span><span
            class="p">:</span>
            <span class="n">flow</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span
            class="n">abs</span><span class="p">(</span><span class="n">function</span><span class="o">.</span><span
            class="n">norm_nabla</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">flow_type</span> <span class="o">==</span> <span class="s1">&#39;curvature&#39;</span><span
            class="p">:</span>
            <span class="n">flow</span> <span class="o">=</span> <span class="n">function</span><span class="o">.</span><span
            class="n">kappa</span> <span class="o">*</span> <span class="n">function</span><span class="o">.</span><span
            class="n">norm_nabla</span>

        <span class="k">if</span> <span class="n">flow_type</span> <span class="o">==</span> <span class="s1">&#39;equi_affine&#39;</span><span
            class="p">:</span>
            <span class="n">flow</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span
            class="n">cbrt</span><span class="p">(</span><span class="n">function</span><span class="o">.</span><span
            class="n">kappa</span><span class="p">)</span> <span class="o">*</span> <span class="n">function</span><span
            class="o">.</span><span class="n">norm_nabla</span>

        <span class="k">if</span> <span class="n">flow_type</span> <span class="o">==</span> <span class="s1">&#39;geodesic&#39;</span><span
            class="p">:</span>
            <span class="c1"># !! pay attention, if self.g is constant - then this flow is actually curvature flow !!</span>

            <span class="n">flow</span> <span class="o">=</span> <span class="bp">self</span><span
            class="o">.</span><span class="n">g</span> <span class="o">*</span> <span class="n">function</span><span
            class="o">.</span><span class="n">kappa</span> <span class="o">*</span> <span class="n">function</span><span
            class="o">.</span><span class="n">norm_nabla</span> <span class="o">+</span> <span class="p">(</span><span
            class="bp">self</span><span class="o">.</span><span class="n">g_x</span> <span class="o">*</span> <span
            class="n">function</span><span class="o">.</span><span class="n">_x</span> <span class="o">+</span> <span
            class="bp">self</span><span class="o">.</span><span class="n">g_y</span> <span class="o">*</span>
                                                                    <span class="n">function</span><span
            class="o">.</span><span class="n">_y</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">open_flag</span><span class="p">:</span>
                <span class="n">psi_t</span> <span class="o">=</span> <span class="bp">self</span><span
            class="o">.</span><span class="n">g</span> <span class="o">*</span> <span class="bp">self</span><span
            class="o">.</span><span class="n">phi</span><span class="p">()</span><span class="o">.</span><span
            class="n">kappa</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span
            class="n">psi</span><span class="o">.</span><span class="n">norm_nabla</span> <span class="o">+</span> <span
            class="p">(</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">g_x</span> <span
            class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">psi</span><span
            class="o">.</span><span class="n">_x</span> <span class="o">+</span> <span class="bp">self</span><span
            class="o">.</span><span class="n">g_y</span> <span class="o">*</span> <span class="bp">self</span><span
            class="o">.</span><span class="n">psi</span><span class="o">.</span><span class="n">_y</span><span
            class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">psi</span><span
            class="o">.</span><span class="n">update</span><span class="p">(</span><span class="bp">self</span><span
            class="o">.</span><span class="n">psi</span><span class="o">.</span><span class="n">value</span> <span
            class="o">-</span> <span class="n">psi_t</span><span class="p">,</span> <span
            class="n">regularization_note</span><span class="o">=</span><span class="n">processing_props</span><span
            class="p">[</span><span class="s1">&#39;regularization&#39;</span><span class="p">])</span>

        <span class="k">if</span> <span class="n">flow_type</span> <span class="o">==</span> <span class="s1">&#39;band&#39;</span><span
            class="p">:</span>
            <span class="n">vb</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span
            class="n">__compute_vb</span><span class="p">(</span><span class="o">**</span><span class="n">processing_props</span><span
            class="p">)</span>
            <span class="n">flow</span> <span class="o">=</span> <span class="n">vb</span> <span
            class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">phi</span><span
            class="p">()</span><span class="o">.</span><span class="n">norm_nabla</span>
            <span class="n">psi_t</span> <span class="o">=</span> <span class="n">vb</span> <span
            class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">psi</span><span
            class="o">.</span><span class="n">norm_nabla</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">psi</span><span class="o">.</span><span
            class="n">update</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span
            class="n">psi</span><span class="o">.</span><span class="n">value</span> <span class="o">+</span> <span
            class="n">psi_t</span><span class="p">,</span> <span class="o">**</span><span
            class="n">processing_props</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">cv2</span><span class="o">.</span><span
            class="n">GaussianBlur</span><span class="p">(</span><span class="n">flow</span><span
            class="p">,</span> <span class="p">(</span><span class="n">processing_props</span><span
            class="p">[</span><span class="s1">&#39;ksize&#39;</span><span class="p">],</span> <span class="n">processing_props</span><span
            class="p">[</span><span class="s1">&#39;ksize&#39;</span><span class="p">]),</span> <span class="n">processing_props</span><span
            class="p">[</span><span class="s1">&#39;sigma&#39;</span><span class="p">])</span></div>

<div class="viewcode-block" id="LevelSetFlow.mumfordshah_flow"><a class="viewcode-back"
                                                                  href="../LevelSets/LevelSetFlow.html#LevelSetFlow.LevelSetFlow.mumfordshah_flow">[docs]</a>    <span
        class="k">def</span> <span class="nf">mumfordshah_flow</span><span class="p">(</span><span
        class="bp">self</span><span class="p">,</span> <span class="n">img</span><span class="o">=</span><span
        class="kc">True</span><span class="p">,</span> <span class="n">nu</span><span class="o">=</span><span
        class="mi">1</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Computes the Mumford-Shah flow for a multi-phase level set, according to :cite:`Vese.Chan2002`.</span>

<span class="sd">        Updates the self.Phi variable for</span>

<span class="sd">        :param img: the specific image upon which the level sets are computed</span>
<span class="sd">        :param nu: the length weight</span>

<span class="sd">        :type img: np.array</span>
<span class="sd">        :type nu: float</span>

<span class="sd">        :return: phi_t - the flows that move the level set</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="n">img</span><span class="p">:</span>
            <span class="n">images</span> <span class="o">=</span> <span class="bp">self</span><span
            class="o">.</span><span class="n">__img</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">images</span> <span class="o">=</span> <span class="n">img</span>

        <span class="n">Phi</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span
            class="n">__Phi</span>

        <span class="n">m_levelsets</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span
            class="n">num_ls</span>
        <span class="n">n_phases</span> <span class="o">=</span> <span class="mi">2</span> <span
            class="o">**</span> <span class="n">m_levelsets</span>
        <span class="n">_combinations</span> <span class="o">=</span> <span class="s1">&#39;01&#39;</span> <span
            class="o">*</span> <span class="n">m_levelsets</span>
        <span class="c1"># fig, ax = plt.subplots(num = &#39;panorama&#39;)</span>

        <span class="kn">import</span> <span class="nn">itertools</span>
        <span class="n">counter</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="n">kappa_flag</span> <span class="o">=</span> <span class="kc">True</span>

        <span class="k">for</span> <span class="n">img</span> <span class="ow">in</span> <span
            class="n">images</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">img</span><span class="o">.</span><span
            class="n">ndim</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
                <span class="n">image</span> <span class="o">=</span> <span class="n">cv2</span><span class="o">.</span><span
            class="n">cvtColor</span><span class="p">(</span><span class="n">img</span><span class="o">.</span><span
            class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span
            class="n">float32</span><span class="p">),</span> <span class="n">cv2</span><span class="o">.</span><span
            class="n">COLOR_RGB2LAB</span><span class="p">)</span>
                <span class="n">images</span><span class="o">.</span><span class="n">append</span><span
            class="p">(</span><span class="n">image</span><span class="p">[:,</span> <span class="p">:,</span> <span
            class="mi">0</span><span class="p">])</span>
                <span class="n">images</span><span class="o">.</span><span class="n">append</span><span
            class="p">(</span><span class="n">image</span><span class="p">[:,</span> <span class="p">:,</span> <span
            class="mi">1</span><span class="p">])</span>
                <span class="n">images</span><span class="o">.</span><span class="n">append</span><span
            class="p">(</span><span class="n">image</span><span class="p">[:,</span> <span class="p">:,</span> <span
            class="mi">2</span><span class="p">])</span>
                <span class="k">continue</span>
            <span class="n">combinations</span> <span class="o">=</span> <span class="n">itertools</span><span
            class="o">.</span><span class="n">combinations</span><span class="p">(</span><span
            class="n">_combinations</span><span class="p">,</span> <span class="n">m_levelsets</span><span
            class="p">)</span>
            <span class="k">for</span> <span class="n">combination</span> <span class="ow">in</span> <span class="n">combinations</span><span
            class="p">:</span>
                <span class="n">dPhi</span> <span class="o">=</span> <span class="bp">self</span><span
            class="o">.</span><span class="n">__ms_element</span><span class="p">(</span><span
            class="n">combination</span><span class="p">,</span> <span class="n">img</span><span class="p">)</span>

                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span
            class="nb">range</span><span class="p">(</span><span class="n">m_levelsets</span><span class="p">):</span>
                    <span class="n">i</span> <span class="o">=</span> <span class="nb">int</span><span
            class="p">(</span><span class="n">i</span><span class="p">)</span>
                    <span class="n">Phi</span><span class="p">[</span><span class="n">i</span><span
            class="p">]</span><span class="o">.</span><span class="n">move_function</span><span class="p">(</span><span
            class="n">dPhi</span><span class="p">[:,</span> <span class="p">:,</span> <span class="n">i</span><span
            class="p">])</span>
                    <span class="n">counter</span> <span class="o">+=</span> <span class="mi">1</span>

                    <span class="k">if</span> <span class="n">counter</span> <span class="o">&gt;</span> <span
            class="n">m_levelsets</span><span class="p">:</span>
                        <span class="n">kappa_flag</span> <span class="o">=</span> <span class="kc">False</span>

                    <span class="k">if</span> <span class="n">kappa_flag</span><span class="p">:</span>
                        <span class="n">Phi</span><span class="p">[</span><span class="n">i</span><span
            class="p">]</span><span class="o">.</span><span class="n">move_function</span><span class="p">(</span><span
            class="n">nu</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span
            class="n">phi</span><span class="p">(</span><span class="n">i</span><span class="p">)</span><span class="o">.</span><span
            class="n">kappa</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">__Phi</span> <span class="o">=</span> <span
            class="n">Phi</span></div>

        <span class="c1"># mt.draw_contours(self.phi(0).value, ax, self.img_rgb, color = &#39;b&#39;)</span>
        <span class="c1"># mt.draw_contours(self.phi(1).value, ax, self.img_rgb, hold = True, color = &#39;r&#39;)</span>
        <span class="c1"># plt.pause(.5e-10)</span>

    <span class="k">def</span> <span class="nf">__ms_element</span><span class="p">(</span><span
            class="bp">self</span><span class="p">,</span> <span class="n">combination</span><span
            class="p">,</span> <span class="n">img</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        An element for summation within the Mumford-Shah model.</span>

<span class="sd">        For example, for a 3-phase model, with a unison of the three level sets (all inside):</span>

<span class="sd">        ..math::</span>

<span class="sd">            \begin{eqnarray}</span>
<span class="sd">            \phi_{1t}\rightarrow(u_{0} - c_{000})^2 \delta(\phi_1)H(\phi_2)H(\phi_3) \\</span>
<span class="sd">            \phi_{2t}\rightarrow(u_{0} - c_{000})^2 H(\phi_1)\delta(\phi_2)H(\phi_3) \\</span>
<span class="sd">            \phi_{3t}\rightarrow(u_{0} - c_{000})^2 H(\phi_1)H(\phi_2)\delta(\phi_3) \\</span>

<span class="sd">        This method comoputes the constant of the region, according to the image</span>

<span class="sd">        :param combination: the current combination of the level-sets (e.g., &#39;000&#39;, &#39;001&#39;, &#39;101&#39;)</span>
<span class="sd">        :param img: the image upon which the level set is moving (for the specific channel)</span>

<span class="sd">        :type combination: tuple</span>
<span class="sd">        :type img: np.array</span>

<span class="sd">        :return: the elements for summation for each level set</span>

<span class="sd">        :rtype: list</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">H</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">diracs</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">mult_dirac</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">dPhi</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span
            class="n">zeros</span><span class="p">((</span><span class="n">img</span><span class="o">.</span><span
            class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span
            class="n">img</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span
            class="mi">1</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span
            class="n">num_ls</span><span class="p">))</span>
        <span class="k">for</span> <span class="n">index</span> <span class="ow">in</span> <span class="nb">range</span><span
            class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">num_ls</span><span
            class="p">):</span>
            <span class="n">i</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span
            class="n">combination</span><span class="p">[</span><span class="n">index</span><span class="p">])</span>
            <span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="mi">0</span><span
            class="p">:</span>  <span class="c1"># inside the level set</span>
                <span class="n">H</span><span class="o">.</span><span class="n">append</span><span
            class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">phi</span><span
            class="p">(</span><span class="n">index</span><span class="p">)</span><span class="o">.</span><span
            class="n">heaviside</span><span class="p">)</span>
                <span class="n">diracs</span><span class="o">.</span><span class="n">append</span><span
            class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">phi</span><span
            class="p">(</span><span class="n">index</span><span class="p">)</span><span class="o">.</span><span
            class="n">dirac_delta</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">H</span><span class="o">.</span><span class="n">append</span><span
            class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="bp">self</span><span
            class="o">.</span><span class="n">phi</span><span class="p">(</span><span class="n">index</span><span
            class="p">)</span><span class="o">.</span><span class="n">heaviside</span><span class="p">)</span>
                <span class="n">diracs</span><span class="o">.</span><span class="n">append</span><span
            class="p">(</span><span class="o">-</span><span class="bp">self</span><span class="o">.</span><span
            class="n">phi</span><span class="p">(</span><span class="n">index</span><span class="p">)</span><span
            class="o">.</span><span class="n">dirac_delta</span><span class="p">)</span>

        <span class="kn">import</span> <span class="nn">functools</span>
        <span class="n">mult</span> <span class="o">=</span> <span class="n">functools</span><span
            class="o">.</span><span class="n">reduce</span><span class="p">(</span><span class="k">lambda</span> <span
            class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="n">x</span> <span
            class="o">*</span> <span class="n">y</span><span class="p">,</span> <span class="n">H</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span
            class="p">(</span><span class="n">mult</span> <span class="o">==</span> <span class="mi">0</span><span
            class="p">):</span>
            <span class="n">c</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">c</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span
            class="n">sum</span><span class="p">(</span><span class="n">img</span> <span class="o">*</span> <span
            class="n">mult</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span
            class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span
            class="n">mult</span><span class="p">))</span>

        <span class="k">for</span> <span class="n">index</span> <span class="ow">in</span> <span class="nb">range</span><span
            class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">num_ls</span><span
            class="p">):</span>
            <span class="n">i</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span
            class="n">index</span><span class="p">)</span>
            <span class="n">H_</span> <span class="o">=</span> <span class="n">H</span><span class="o">.</span><span
            class="n">copy</span><span class="p">()</span>
            <span class="n">H_</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span
            class="n">i</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">H_</span><span
            class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">H_</span> <span class="o">=</span> <span class="n">functools</span><span
            class="o">.</span><span class="n">reduce</span><span class="p">(</span><span class="k">lambda</span> <span
            class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="n">x</span> <span
            class="o">*</span> <span class="n">y</span><span class="p">,</span> <span class="n">H_</span><span
            class="p">)</span>
                <span class="n">mult_dirac</span><span class="o">.</span><span class="n">append</span><span
            class="p">(</span><span class="n">diracs</span><span class="p">[</span><span class="n">i</span><span
            class="p">]</span> <span class="o">*</span> <span class="n">H_</span><span class="p">)</span>

            <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span
            class="n">H_</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span
            class="p">:</span>
                <span class="n">mult_dirac</span> <span class="o">=</span> <span class="p">[</span><span class="n">diracs</span><span
            class="p">[</span><span class="n">i</span><span class="p">]]</span>

            <span class="k">else</span><span class="p">:</span>
                <span class="n">H_</span> <span class="o">=</span> <span class="n">H_</span><span
            class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">mult_dirac</span><span class="o">.</span><span class="n">append</span><span
            class="p">(</span><span class="n">diracs</span><span class="p">[</span><span class="n">i</span><span
            class="p">]</span> <span class="o">*</span> <span class="n">H_</span><span class="p">)</span>
            <span class="n">dPhi</span><span class="p">[:,</span> <span class="p">:,</span> <span
            class="n">i</span><span class="p">]</span> <span class="o">+=</span> <span class="p">(</span><span
            class="n">img</span> <span class="o">-</span> <span class="n">c</span><span class="p">)</span> <span
            class="o">**</span> <span class="mi">2</span> <span class="o">*</span> <span
            class="n">mult_dirac</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>

        <span class="k">return</span> <span class="n">dPhi</span>

    <span class="k">def</span> <span class="nf">__compute_vb</span><span class="p">(</span><span
            class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span
            class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Computes the band velocity, according to Li et al., 2006.</span>

<span class="sd">        :param img: the image upon which the contour is searched</span>
<span class="sd">        :param phi: the level set function</span>
<span class="sd">        :param band_width: the width of the contour. default: 5</span>
<span class="sd">        :param threshold: for when the velocity equals zero. default: 0.5</span>
<span class="sd">        :param stepsize. default 0.05</span>

<span class="sd">        :return: vb</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">band_width</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span
            class="n">get</span><span class="p">(</span><span class="s1">&#39;band_width&#39;</span><span
            class="p">,</span> <span class="mf">1.e-3</span><span class="p">)</span>
        <span class="n">threshold</span> <span class="o">=</span> <span class="n">kwargs</span><span
            class="o">.</span><span class="n">get</span><span class="p">(</span><span
            class="s1">&#39;threshold&#39;</span><span class="p">,</span> <span class="mf">0.5</span><span
            class="p">)</span>
        <span class="n">tau</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span
            class="n">get</span><span class="p">(</span><span class="s1">&#39;stepsize&#39;</span><span
            class="p">,</span> <span class="mf">0.05</span><span class="p">)</span>
        <span class="n">phi</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span
            class="n">phi</span><span class="p">()</span><span class="o">.</span><span class="n">value</span>

        <span class="c1"># Define the areas for R and R&#39;</span>
        <span class="n">R</span> <span class="o">=</span> <span class="p">(</span><span class="n">phi</span> <span
            class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="o">*</span> <span
            class="p">(</span><span class="n">phi</span> <span class="o">&lt;=</span> <span
            class="n">band_width</span><span class="p">)</span>
        <span class="n">R_</span> <span class="o">=</span> <span class="p">(</span><span class="n">phi</span> <span
            class="o">&gt;=</span> <span class="o">-</span><span class="n">band_width</span><span
            class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">phi</span> <span
            class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>

        <span class="n">SR</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span
            class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span
            class="n">img</span><span class="p">()</span><span class="o">.</span><span class="n">shape</span><span
            class="p">[:</span><span class="mi">2</span><span class="p">])</span>
        <span class="n">SR_</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span
            class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span
            class="n">img</span><span class="p">()</span><span class="o">.</span><span class="n">shape</span><span
            class="p">[:</span><span class="mi">2</span><span class="p">])</span>

        <span class="n">SR</span><span class="p">[</span><span class="n">R</span><span class="p">]</span> <span
            class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span
            class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">img</span><span
            class="p">()[</span><span class="n">R</span><span class="p">])</span>
        <span class="n">SR_</span><span class="p">[</span><span class="n">R_</span><span class="p">]</span> <span
            class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span
            class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">img</span><span
            class="p">()[</span><span class="n">R_</span><span class="p">])</span>
        <span class="n">vb</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">-</span> <span
            class="p">(</span><span class="n">SR_</span> <span class="o">-</span> <span class="n">SR</span><span
            class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">np</span><span
            class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span
            class="p">(</span><span class="n">SR</span> <span class="o">+</span> <span class="n">SR_</span><span
            class="p">)</span> <span class="o">+</span> <span class="n">EPS</span><span class="p">)</span>
        <span class="n">vb</span><span class="p">[</span><span class="n">vb</span> <span class="o">&lt;</span> <span
            class="n">threshold</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">vb</span> <span class="o">*=</span> <span class="n">tau</span>
        <span class="c1">#  vb[np.where(phi != 0)] = 0</span>
        <span class="k">return</span> <span class="n">vb</span> <span class="o">*</span> <span
            class="bp">self</span><span class="o">.</span><span class="n">phi</span><span class="p">()</span><span
            class="o">.</span><span class="n">kappa</span>

    <span class="k">def</span> <span class="nf">__compute_vt</span><span class="p">(</span><span
            class="bp">self</span><span class="p">,</span> <span class="n">vectorField</span><span
            class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span
            class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Computes the vector field derivative in each direction according to</span>
<span class="sd">        .. math:: v_t = g(|\nabla f|)\nabla^2 * v - h(|\nabla f|)*(v - \nabla f)</span>

<span class="sd">        :param vectorField: usually created based on an edge map; nxmx2 (for x and y directions)</span>
<span class="sd">        :param edge_map:</span>
<span class="sd">        :param kappa: curvature map</span>
<span class="sd">        :param verbose: show vector field</span>

<span class="sd">        :type verbose: bool</span>

<span class="sd">        **Optionals**</span>
<span class="sd">        gradient computation parameters</span>

<span class="sd">        :param gradientType:</span>
<span class="sd">        :param ksize:</span>
<span class="sd">        :param sigma:</span>


<span class="sd">        :return vt: velocity for x and y directions</span>
<span class="sd">         :type vt: nd-array nxmx2</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># compute the derivatives of the edge map at each direction</span>
        <span class="n">nabla_edge</span> <span class="o">=</span> <span class="n">mt</span><span
            class="o">.</span><span class="n">computeImageGradient</span><span class="p">(</span><span
            class="bp">self</span><span class="o">.</span><span class="n">f</span><span class="p">,</span> <span
            class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

        <span class="c1"># compute the Laplacian of the vector field</span>
        <span class="n">laplacian_vx</span> <span class="o">=</span> <span class="n">cv2</span><span
            class="o">.</span><span class="n">Laplacian</span><span class="p">(</span><span class="n">vectorField</span><span
            class="p">[:,</span> <span class="p">:,</span> <span class="mi">0</span><span class="p">],</span> <span
            class="n">cv2</span><span class="o">.</span><span class="n">CV_64F</span><span class="p">)</span>
        <span class="n">laplacian_vy</span> <span class="o">=</span> <span class="n">cv2</span><span
            class="o">.</span><span class="n">Laplacian</span><span class="p">(</span><span class="n">vectorField</span><span
            class="p">[:,</span> <span class="p">:,</span> <span class="mi">1</span><span class="p">],</span> <span
            class="n">cv2</span><span class="o">.</span><span class="n">CV_64F</span><span class="p">)</span>

        <span class="c1"># compute the functions that are part of the vt computation</span>
        <span class="n">g</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span
            class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="n">nabla_edge</span> <span
            class="o">/</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span
            class="n">phi</span><span class="p">()</span><span class="o">.</span><span class="n">kappa</span> <span
            class="o">+</span> <span class="n">EPS</span><span class="p">)</span> <span class="o">**</span> <span
            class="mi">2</span><span class="p">)</span>
        <span class="n">h</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">-</span> <span
            class="n">g</span>

        <span class="n">vx_t</span> <span class="o">=</span> <span class="n">g</span> <span class="o">*</span> <span
            class="n">laplacian_vx</span> <span class="o">-</span> <span class="n">h</span> <span
            class="o">*</span> <span class="p">(</span><span class="n">vectorField</span><span
            class="p">[:,</span> <span class="p">:,</span> <span class="mi">0</span><span class="p">]</span> <span
            class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">f</span><span
            class="p">)</span>
        <span class="n">vy_t</span> <span class="o">=</span> <span class="n">g</span> <span class="o">*</span> <span
            class="n">laplacian_vy</span> <span class="o">-</span> <span class="n">h</span> <span
            class="o">*</span> <span class="p">(</span><span class="n">vectorField</span><span
            class="p">[:,</span> <span class="p">:,</span> <span class="mi">1</span><span class="p">]</span> <span
            class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">f</span><span
            class="p">)</span>

        <span class="k">if</span> <span class="n">verbose</span> <span class="o">==</span> <span
            class="kc">True</span><span class="p">:</span>
            <span class="c1"># plt.quiver(vx_t, vy_t, scale=25)</span>
            <span class="c1"># plt.show()</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">()</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span
            class="n">vectorField</span><span class="p">[:,</span> <span class="p">:,</span> <span
            class="mi">0</span><span class="p">])</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">()</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span
            class="n">vectorField</span><span class="p">[:,</span> <span class="p">:,</span> <span
            class="mi">1</span><span class="p">])</span>

        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">stack</span><span
            class="p">((</span><span class="o">-</span><span class="n">vx_t</span><span class="p">,</span> <span
            class="o">-</span><span class="n">vy_t</span><span class="p">),</span> <span class="n">axis</span><span
            class="o">=</span><span class="mi">2</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__compute_vo</span><span class="p">(</span><span
            class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span
            class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Computes velocity under orhogonality constraint (the force is computed so that the contours will be orthogonal</span>
<span class="sd">        to another function (psi)</span>

<span class="sd">        :param kwargs:</span>

<span class="sd">        :return:</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">psi</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span
            class="n">get</span><span class="p">(</span><span class="s1">&#39;function&#39;</span><span
            class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">psi</span><span
            class="p">)</span>  <span
            class="c1"># if no other function is given it will be moving according to psi</span>

        <span class="n">grad_psi_grad_phi</span> <span class="o">=</span> <span class="n">psi</span><span
            class="o">.</span><span class="n">_x</span> <span class="o">*</span> <span class="bp">self</span><span
            class="o">.</span><span class="n">phi</span><span class="p">()</span><span class="o">.</span><span
            class="n">_x</span> <span class="o">+</span> <span class="n">psi</span><span class="o">.</span><span
            class="n">_y</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span
            class="n">phi</span><span class="p">()</span><span class="o">.</span><span class="n">_y</span>

        <span class="k">return</span> <span class="n">grad_psi_grad_phi</span> <span class="o">/</span> <span class="p">(</span><span
            class="bp">self</span><span class="o">.</span><span class="n">phi</span><span class="p">()</span><span
            class="o">.</span><span class="n">norm_nabla</span> <span class="o">+</span> <span class="n">EPS</span><span
            class="p">)</span>

<div class="viewcode-block" id="LevelSetFlow.moveLS"><a class="viewcode-back"
                                                        href="../LevelSets/LevelSetFlow.html#LevelSetFlow.LevelSetFlow.moveLS">[docs]</a>    <span
        class="k">def</span> <span class="nf">moveLS</span><span class="p">(</span><span class="bp">self</span><span
        class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The function that moves the level set until the desired contour is reached</span>

<span class="sd">        :param flow_type -  flow types and their weight (string, weight):</span>

<span class="sd">        &#39;constant&#39;, &#39;curvature&#39;, &#39;equi-affine&#39;, &#39;geodesic&#39;, &#39;chan-vese&#39;, &#39;band&#39;</span>

<span class="sd">        .. note:: The &#39;chan-vese&#39; flow requires weights (chanvese_w), for the four components of the model:</span>

<span class="sd">        .. code-block:: python</span>

<span class="sd">            {area_w, length_w, inside_w, outside_w}</span>

<span class="sd">        :param gvf_flag: flag to add gradient vector flow</span>
<span class="sd">        :param open_flag: flag for open contours</span>
<span class="sd">        :param mumford_shah: flag for mumford_shah flow</span>
<span class="sd">        :param scaleX: enhance X direction</span>
<span class="sd">        :param scaleY: enhance Y direction</span>

<span class="sd">        :type scaleX: float</span>
<span class="sd">        :type scaleY: float</span>

<span class="sd">        :return the contours after level set</span>

<span class="sd">         &quot;&quot;&quot;</span>
        <span class="c1"># ------inputs--------</span>
        <span class="n">verbose</span> <span class="o">=</span> <span class="n">kwargs</span><span
            class="o">.</span><span class="n">get</span><span class="p">(</span><span
            class="s1">&#39;verbose&#39;</span><span class="p">,</span> <span class="kc">False</span><span
            class="p">)</span>
        <span class="n">open_flag</span> <span class="o">=</span> <span class="n">kwargs</span><span
            class="o">.</span><span class="n">get</span><span class="p">(</span><span
            class="s1">&#39;open_flag&#39;</span><span class="p">,</span> <span class="kc">False</span><span
            class="p">)</span>
        <span class="n">mumford_shah_flag</span> <span class="o">=</span> <span class="n">kwargs</span><span
            class="o">.</span><span class="n">get</span><span class="p">(</span><span
            class="s1">&#39;mumford_shah&#39;</span><span class="p">,</span> <span class="kc">False</span><span
            class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">scale_x</span> <span
            class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span
            class="p">(</span><span class="s1">&#39;scaleX&#39;</span><span class="p">,</span> <span
            class="mf">1.</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">scale_y</span> <span
            class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span
            class="p">(</span><span class="s1">&#39;scaleY&#39;</span><span class="p">,</span> <span
            class="mf">1.</span><span class="p">)</span>

        <span class="n">nu</span> <span class="o">=</span> <span class="mf">1.</span>
        <span class="n">blob_size</span> <span class="o">=</span> <span class="n">kwargs</span><span
            class="o">.</span><span class="n">get</span><span class="p">(</span><span
            class="s1">&#39;blob_size&#39;</span><span class="p">,</span> <span class="mi">1</span><span
            class="p">)</span>
        <span class="k">if</span> <span class="n">mumford_shah_flag</span><span class="p">:</span>
            <span class="n">nu</span> <span class="o">=</span> <span class="n">kwargs</span><span
            class="o">.</span><span class="n">get</span><span class="p">(</span><span
            class="s1">&#39;nu&#39;</span><span class="p">,</span> <span class="mf">1.</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span
            class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">img_rgb</span><span
            class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">temp</span> <span class="o">=</span> <span class="bp">self</span><span
            class="o">.</span><span class="n">img_rgb</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">temp</span> <span class="o">=</span> <span class="bp">self</span><span
            class="o">.</span><span class="n">img</span>

        <span class="n">img_showed</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span
            class="n">get</span><span class="p">(</span><span class="s1">&#39;image_showed&#39;</span><span
            class="p">,</span> <span class="n">temp</span><span class="p">)</span>

        <span class="c1"># -------- initializations ---------</span>
        <span class="n">flow_types</span> <span class="o">=</span> <span class="bp">self</span><span
            class="o">.</span><span class="n">flow_types</span>
        <span class="n">regularization_epsilon</span> <span class="o">=</span> <span class="bp">self</span><span
            class="o">.</span><span class="n">regularization_epsilon</span>
        <span class="n">iterations</span> <span class="o">=</span> <span class="bp">self</span><span
            class="o">.</span><span class="n">iterations</span>

        <span class="n">gvf_w</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span
            class="n">gvf_w</span>
        <span class="n">vo_w</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span
            class="n">vo_w</span>
        <span class="n">region_w</span> <span class="o">=</span> <span class="bp">self</span><span
            class="o">.</span><span class="n">region_w</span>
        <span class="n">processing_props</span> <span class="o">=</span> <span class="bp">self</span><span
            class="o">.</span><span class="n">processing_props</span>

        <span class="n">fig</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span
            class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span
            class="n">num</span><span class="o">=</span><span class="s1">&#39;img&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span
            class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">img_rgb</span><span
            class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">mt</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span
            class="bp">self</span><span class="o">.</span><span class="n">img_rgb</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">mt</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span
            class="bp">self</span><span class="o">.</span><span class="n">img</span><span class="p">)</span>

        <span class="n">ax2</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span
            class="n">figure</span><span class="p">(</span><span class="s2">&quot;phi&quot;</span><span
            class="p">)</span>
        <span class="n">mt</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span
            class="bp">self</span><span class="o">.</span><span class="n">phi</span><span class="p">()</span><span
            class="o">.</span><span class="n">value</span><span class="p">)</span>
        <span class="n">fig3</span><span class="p">,</span> <span class="n">ax3</span> <span class="o">=</span> <span
            class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span
            class="n">num</span><span class="o">=</span><span class="s1">&#39;kappa&#39;</span><span class="p">)</span>
        <span class="n">mt</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span
            class="bp">self</span><span class="o">.</span><span class="n">phi</span><span class="p">()</span><span
            class="o">.</span><span class="n">kappa</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">open_flag</span><span class="p">:</span>
            <span class="n">fig4</span><span class="p">,</span> <span class="n">ax4</span> <span
            class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span
            class="p">(</span><span class="n">num</span><span class="o">=</span><span
            class="s1">&#39;psi&#39;</span><span class="p">)</span>
            <span class="n">mt</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span
            class="bp">self</span><span class="o">.</span><span class="n">psi</span><span class="o">.</span><span
            class="n">value</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span
            class="nb">range</span><span class="p">(</span><span class="n">iterations</span><span class="p">):</span>
            <span class="nb">print</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">i</span> <span class="o">&gt;</span> <span
            class="mi">26</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;hello&#39;</span><span
            class="p">)</span>
            <span class="n">intrinsic</span> <span class="o">=</span> <span class="n">np</span><span
            class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span
            class="o">.</span><span class="n">img</span><span class="p">()</span><span class="o">.</span><span
            class="n">shape</span><span class="p">[:</span><span class="mi">2</span><span class="p">])</span>
            <span class="n">extrinsic</span> <span class="o">=</span> <span class="n">np</span><span
            class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span
            class="o">.</span><span class="n">img</span><span class="p">()</span><span class="o">.</span><span
            class="n">shape</span><span class="p">[:</span><span class="mi">2</span><span class="p">])</span>

            <span class="c1"># ---------- intrinsic movement ----------</span>
            <span class="k">if</span> <span class="n">mumford_shah_flag</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">mumfordshah_flow</span><span
            class="p">(</span><span class="n">nu</span><span class="p">)</span>

            <span class="c1"># regular flows</span>
            <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span
            class="nb">list</span><span class="p">(</span><span class="n">flow_types</span><span class="o">.</span><span
            class="n">keys</span><span class="p">()):</span>
                <span class="k">if</span> <span class="n">flow_types</span><span class="p">[</span><span
            class="n">item</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span
            class="p">:</span>
                    <span class="k">continue</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span
            class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span
            class="n">num_ls</span><span class="p">):</span>
                    <span class="n">intrinsic</span> <span class="o">+=</span> <span class="n">flow_types</span><span
            class="p">[</span><span class="n">item</span><span class="p">]</span> <span class="o">*</span> <span
            class="bp">self</span><span class="o">.</span><span class="n">flow</span><span class="p">(</span><span
            class="n">item</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span
            class="n">phi</span><span class="p">(</span><span class="n">i</span><span class="p">),</span> <span
            class="n">open_flag</span><span class="p">,</span> <span class="n">processing_props</span><span
            class="p">)</span>

                <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span
            class="n">any</span><span class="p">(</span><span class="n">intrinsic</span> <span
            class="o">&gt;</span> <span class="mi">20</span><span class="p">):</span>
                        <span class="nb">print</span><span class="p">(</span><span class="n">i</span><span
            class="p">)</span>

            <span class="c1"># region force</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span
            class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">num_ls</span><span
            class="p">):</span>
                <span class="n">intrinsic</span> <span class="o">+=</span> <span class="n">region_w</span> <span
            class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">region</span> <span
            class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">phi</span><span
            class="p">(</span><span class="n">i</span><span class="p">)</span><span class="o">.</span><span class="n">norm_nabla</span>

            <span class="c1"># ---------------extrinsic movement ----------</span>
            <span class="n">v</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span
            class="n">stack</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span
            class="n">f_x</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span
            class="n">f_y</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span
            class="mi">2</span><span class="p">)</span>
            <span class="n">vt</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span
            class="n">__compute_vt</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span
            class="n">verbose</span><span class="o">=</span><span class="n">verbose</span><span class="p">,</span> <span
            class="o">**</span><span class="n">processing_props</span><span class="p">)</span>
            <span class="n">v</span> <span class="o">+=</span> <span class="n">vt</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span
            class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">num_ls</span><span
            class="p">):</span>
                <span class="n">extrinsic</span> <span class="o">=</span> <span class="p">(</span><span
            class="n">v</span><span class="p">[:,</span> <span class="p">:,</span> <span class="mi">0</span><span
            class="p">]</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span
            class="n">phi</span><span class="p">(</span><span class="n">i</span><span class="p">)</span><span class="o">.</span><span
            class="n">_x</span> <span class="o">+</span> <span class="n">v</span><span class="p">[:,</span> <span
            class="p">:,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span
            class="bp">self</span><span class="o">.</span><span class="n">phi</span><span class="p">(</span><span
            class="n">i</span><span class="p">)</span><span class="o">.</span><span class="n">_y</span><span
            class="p">)</span> <span class="o">*</span> <span class="n">gvf_w</span>

                <span class="c1"># for constrained contours</span>
                <span class="n">extrinsic</span> <span class="o">+=</span> <span class="bp">self</span><span
            class="o">.</span><span class="n">__compute_vo</span><span class="p">()</span> <span
            class="o">*</span> <span class="n">vo_w</span>
                <span class="n">phi_t</span> <span class="o">=</span> <span class="bp">self</span><span
            class="o">.</span><span class="n">step</span> <span class="o">*</span> <span class="p">(</span><span
            class="n">intrinsic</span> <span class="o">-</span> <span class="n">extrinsic</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">phi</span><span
            class="p">(</span><span class="n">i</span><span class="p">)</span><span class="o">.</span><span class="n">move_function</span><span
            class="p">(</span><span class="n">phi_t</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">phi</span><span
            class="p">(</span><span class="n">i</span><span class="p">)</span><span class="o">.</span><span class="n">update</span><span
            class="p">(</span><span class="n">cv2</span><span class="o">.</span><span class="n">normalize</span><span
            class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">phi</span><span
            class="p">(</span><span class="n">i</span><span class="p">)</span><span class="o">.</span><span class="n">value</span><span
            class="o">.</span><span class="n">astype</span><span class="p">(</span><span
            class="s1">&#39;float&#39;</span><span class="p">),</span> <span class="kc">None</span><span
            class="p">,</span> <span class="o">-</span><span class="mf">1.0</span><span class="p">,</span> <span
            class="mf">1.0</span><span class="p">,</span> <span class="n">cv2</span><span class="o">.</span><span
            class="n">NORM_MINMAX</span><span class="p">))</span>

            <span class="c1"># extrinsic += (1 - mult_phi)</span>
            <span class="c1">#  self.psi += extrinsic</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span
            class="s1">&#39;kappa&#39;</span><span class="p">)</span>
            <span class="n">mt</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span
            class="bp">self</span><span class="o">.</span><span class="n">phi</span><span class="p">()</span><span
            class="o">.</span><span class="n">kappa</span><span class="p">)</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">pause</span><span class="p">(</span><span
            class="o">.</span><span class="mf">5e-10</span><span class="p">)</span>

            <span class="c1"># if np.max(np.abs(phi_t)) &lt;= 5e-5:</span>
            <span class="c1">#     print(&#39;done&#39;)</span>
            <span class="c1">#     return</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span
            class="s1">&#39;phi&#39;</span><span class="p">)</span>
            <span class="n">mt</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span
            class="bp">self</span><span class="o">.</span><span class="n">phi</span><span class="p">()</span><span
            class="o">.</span><span class="n">value</span><span class="p">)</span>

            <span class="c1"># if open_flag:</span>
            <span class="c1">#     for curve in l_curve:</span>
            <span class="c1">#         self.phi().value[curve._y.astype(&#39;int&#39;), curve._x.astype(&#39;int&#39;)] = 0</span>

            <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span
            class="s1">&#39;img&#39;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">open_flag</span><span class="p">:</span>
                <span class="n">_</span><span class="p">,</span> <span class="n">ax</span> <span
            class="o">=</span> <span class="n">mt</span><span class="o">.</span><span
            class="n">draw_contours</span><span class="p">(</span><span class="bp">self</span><span
            class="o">.</span><span class="n">phi</span><span class="p">()</span><span class="o">.</span><span
            class="n">value</span><span class="p">,</span> <span class="n">ax</span><span class="p">,</span> <span
            class="n">color</span><span class="o">=</span><span class="s1">&#39;r&#39;</span><span
            class="p">,</span> <span class="n">img</span><span class="o">=</span><span class="n">img_showed</span><span
            class="p">,</span>
                                         <span class="nb">open</span><span class="o">=</span><span
            class="kc">True</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">colors</span> <span class="o">=</span> <span class="s1">&#39;rbgm&#39;</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span
            class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span
            class="bp">self</span><span class="o">.</span><span class="n">__Phi</span><span class="p">)):</span>
                    <span class="k">if</span> <span class="n">i</span> <span class="o">&gt;</span> <span
            class="mi">0</span><span class="p">:</span>
                        <span class="n">l_curve</span><span class="p">,</span> <span class="n">ax</span> <span
            class="o">=</span> <span class="n">mt</span><span class="o">.</span><span
            class="n">draw_contours</span><span class="p">(</span><span class="bp">self</span><span
            class="o">.</span><span class="n">phi</span><span class="p">(</span><span class="n">i</span><span class="p">)</span><span
            class="o">.</span><span class="n">value</span><span class="p">,</span> <span class="n">ax</span><span
            class="p">,</span> <span class="n">img</span><span class="o">=</span><span class="n">img_showed</span><span
            class="p">,</span> <span class="n">hold</span><span class="o">=</span><span class="kc">True</span><span
            class="p">,</span>
                                                       <span class="n">color</span><span class="o">=</span><span
            class="n">colors</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span
            class="n">blob_size</span><span class="o">=</span><span class="n">blob_size</span><span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">l_curve</span><span class="p">,</span> <span class="n">ax</span> <span
            class="o">=</span> <span class="n">mt</span><span class="o">.</span><span
            class="n">draw_contours</span><span class="p">(</span><span class="bp">self</span><span
            class="o">.</span><span class="n">phi</span><span class="p">(</span><span class="n">i</span><span class="p">)</span><span
            class="o">.</span><span class="n">value</span><span class="p">,</span> <span class="n">ax</span><span
            class="p">,</span> <span class="n">img</span><span class="o">=</span><span class="n">img_showed</span><span
            class="p">,</span> <span class="n">hold</span><span class="o">=</span><span class="kc">False</span><span
            class="p">,</span>
                                                       <span class="n">color</span><span class="o">=</span><span
            class="n">colors</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span
            class="n">blob_size</span><span class="o">=</span><span class="n">blob_size</span><span class="p">)</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">pause</span><span class="p">(</span><span
            class="o">.</span><span class="mf">5e-10</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Done&#39;</span><span
            class="p">)</span>
        <span class="k">return</span> <span class="n">l_curve</span></div></div>
</pre>
                        </div>

                    </div>

                </div>
                <footer>


                    <hr/>

                    <div role="contentinfo">
                        <p>
                            &copy; Copyright 2018, Sagi Students.

                        </p>
                    </div>
                    Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a
                        href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a
                        href="https://readthedocs.org">Read the Docs</a>.

                </footer>

            </div>
        </div>

    </section>

</div>


<script type="text/javascript">
    var DOCUMENTATION_OPTIONS = {
        URL_ROOT: '../',
        VERSION: '1a',
        LANGUAGE: 'None',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE: true,
        SOURCELINK_SUFFIX: '.txt'
    };
</script>
<script src="../_static/jquery.js" type="text/javascript"></script>
<script src="../_static/underscore.js" type="text/javascript"></script>
<script src="../_static/doctools.js" type="text/javascript"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"
        type="text/javascript"></script>


<script src="../_static/js/theme.js" type="text/javascript"></script>

<script type="text/javascript">
    jQuery(function () {
        SphinxRtdTheme.Navigation.enable(true);
    });
</script>

</body>
</html>